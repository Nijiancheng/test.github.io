---
layout: post
title:  "C语言指针"
categories: Note
tags: Note
description: 2019-07-19-C语言指针.
---

#### C语言指针：

​	c语言函数内的变量也是局部变量，函数内调用其他函数所传值被改变后不会对原函数变量产生影响。

​	实参前加上&，形参前加上*，表示指针

​	使用gdb工具进行单点调试

​gcc -g main.c -o main.out  | 将文件转成可支持gdb调和斯的文件格式
--|--
gdb  ./main.out | #执行调试文件
l （list）| #显示源代码
enter | #继续执行上一条命令
start | #开始调试
p/print |#打印对应的值
n | 继续下一行代码
$1/$2/$3 | 代表第一第二第三执行结果
s | #进入函数内部
bt | #查看函数堆栈
f 1 | 切换到1函数
x/3d <x0fffff...> | 从某内存地址开始按照十进制类型连续显示三位
q |退出调试模式

---
#### 计算机中数据的表示方法：
计算机中一般以16进制数来自动分配保存的地址
一个十六进制数等于四个2进制的数
内存分层| 
--|--
系统内核|#用于给系统自己处理的内存空间：24个16进制字节
栈内存 |#系统自动分配当执行代码程序时，需要在栈内分配
数据的内存 |
自由分配区 | #用于个人处理数据自由分配的空间
堆 | #一般有程序员分配释放，或程序结束时有os回首，分配方式类似与链表
数据段 | #用于存储global const

---

#### 指针和内存的实质：

```c
//有指针
#include <stdio.h>
void change(int *a,int *b)
{
    int num = *a;
    *a = *b;
    *b = num;
    return 0;
}
int main ()
{
    int a=5;
    int b=3;
    change(&a, &b);
    printf("a=%d \n b=%d \n",a,b);
}
输出 3，5
//无指针
#include <stdio.h>
void change(int a,int b)
{
    int num = a;
    a = b;
    b = num;
    return 0;
}
int main ()
{
    int a=5;
    int b=3;
    change(a,b);
    printf("a=%d \n b=%d \n",a,b);
    return 0;
}        
输出 5，3
```

---

### 内存中各个类型的内存大小：

在分配地址中，编译器会进行内存分配优化，会将所有同类型的分配在相邻；

1. 整型类型：		32位b		4字节；
2. 64位系统下指针内存地址会占	64位b	8字节；
3. 32位系统下指针内存地址会占	32位b	4字节；

---

#### 数组指针和字符指针：

​		直接查看整个数组的指针，会显示数组中第一个元素的指针地址

​		字符指针：指针字符无法修改值因为其地址是位于代码段推栈内存可更改，代码段存储程序编译后得到的机器码，不允许更改

---

#### 指针的运算：
操作 |作用
--|--
指针加：	|	#会先判断指针下的值是什么类型，然后在根据类型所占空间大小增加字节位数；
指针偏移：   |	p代表指针;		p+=3;		代表讲指针p向下移动三位（每位的字节数会根据数据类型进行变化）！；

#### 注意：

1. linux gcc 可使用&& 符号链接命令，等前方的命令成功后再执行后方命令

2. 使用echo &?可得到main函数return的值 

3. int 整形占4字节 char 为字符串 float 为浮点数

4. C语言指针语法 int *a=&b; //前加*  & 取地址符

5. 32位系统地址总线是32位也就是寻址空间是32位 指给内存编号只能编到32个二进制位

6. 用户内存隔离开的好处: 
                 
                 ​	1.操作系统内存不会被大量占用
                 ​    2.避免机器卡住,卡死,死机等
                 ​    3.可通过操作系统吧应用程序关闭使操作系统更安全
                 
7. C语言语法不允许直接操作代码段

